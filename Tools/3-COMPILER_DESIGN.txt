%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                              %
%    Artifact for OOPSLA Paper 230             %
%    Shiftry: RNN Inference in 2 KB of RAM     %
%                                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Design of the Compiler
======================

This file presents a high level overview of how the compiler is written.
Not all files are described. Only a few files, which describe the backbone of the compiler are described.
For an example of how to extend the compiler, check out the ADDING_FUNCTIONS guide.
The Shiftry compiler is built on top of the Seedot framework.
The organisation of this description is as follows:

<Description>:		<Class Name>
						<Member function A>			(All methods are in the order which they are called by the parent)
							Description of A
							->Method B invoked by Member function	A
								Description of B	
								->Method C invoked by function B
									Description of C
							->Second method invoked by Member function A 
								...

Driver code:		main.py
						1. main.py::convert()					
							This method converts the model parameters and inputs from floating point to fixed point code by invoking the Converter object (converter.py)
						2. main.py::performSearch()				
							This method is responsible for generating different scales and bitwidths according which candidate target codes would be generated.
							The following two methods are invoked repeatedly for multiple stage of the exploration. These stages are the ones described as annotations to the program output in the GETTING_STARTED guide
							-> main.py::partialCompile()		
								This is invoked by performSearch() with one particular assignment of scales and bitwidths. This method calls the Compiler object described below and generates the appropriate code
							-> main.py::runAll()				
								This is invoked by performSearch() and it calls the Predictor object (predictor.py) which takes the code generated by partialCompile(), builds, executes and evaluates the accuracy of the target code on the given dataset
						3. main.py::compileFixedForTarget() / main.py::compileFloatForTarget()
							These methods are used to dump the final output code which can be run on an Arduino Uno.

Compiler code:		compiler.py
						1. compiler.py::run()
							This method takes the input code, information about variable scales and bitwidths and generates the fixed point code through the following methods.
							-> compiler.py::genAST()
								This method takes in the input code and converts it into an AST
							-> compiler.py::InferType()
								This object is used to type check the input AST and annotate the AST with the types of all variables
							-> compiler.py::compile()
								-> compiler.py::readDataDrivenScales()
									This method is called during fixed point code generation, and it computes the ranges of values taken by intermediate variables for data driven scaling (Section 5.1 of the paper)
								-> compiler.py::IRBuilder
									This object takes the type annotated AST and translates it into the output code, which is a sequence of function calls
							-> compiler.py::codegen.printAll()
								This method takes the output of IRBuilder and generates the output code, either for X86 or Arduino